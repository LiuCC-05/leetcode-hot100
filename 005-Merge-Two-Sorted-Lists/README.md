# 21. 合并两个有序链表 (Merge Two Sorted Lists) 🔗

### 📝 题目描述
将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

---

### 🚀 两种算法思路对比

针对此问题，我实现了两种不同维度的解法，分别代表了“通用暴力”与“极致优化”的思维：

| 特性 | 方法一：列表排序法 (Violent Sort) | 方法二：双指针迭代法 (Iterative Merge) |
|---|---|---|
| **核心逻辑** | 收集节点 -> 列表排序 -> 重新连接 | 谁小取谁 -> 移动指针 -> 挂载剩余 |
| **时间复杂度** | **$O(n \log n)$** (受排序函数限制) | **$O(n)$** (仅需遍历一次) |
| **空间复杂度** | **$O(n)$** (需要额外 List 存储引用) | **$O(1)$** (原地修改指针指向) |
| **适用场景** | 列表本身无序的情况 | **面试推荐**，利用了题目已排序的特性 |

---

### 💡 核心技术点解析

#### 1. 虚拟头节点 (Dummy Node) 🛡️
在方法二中，我使用了 `dummy = ListNode(0)`。这个小小的“假头”能帮我们避开“第一个节点该接谁”的繁琐判断，统一了合并逻辑，最后只需返回 `dummy.next`。

#### 2. 多条件排序 (Multi-condition Sort) ⚖️
在方法一的排序中，我使用了元组作为 `key`：
`key = lambda x: (x.val, id(x))`
*   **第一级**：按数值 `val` 升序排。
*   **第二级**：如果数值一样，按内存地址 `id` 排，确保排序的唯一性和稳定性。

#### 3. 极速封尾 (Tail Attachment) 🏁
`curr.next = list1 if list1 else list2`
这行代码展示了链表极其高效的一面：只要其中一个链表走完了，剩下的那一部分由于本身就有序，我们**不需要循环**，直接把指针连过去，整串车厢就瞬间合并完成了。

---
