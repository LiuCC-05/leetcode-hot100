# 005. 合并两个有序链表 (Merge Two Sorted Lists) 🔗

### 📝 题目描述
将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

---

### 🚀 两种算法思路对比

针对此问题，我实现了两种不同维度的解法，分别代表了“通用暴力”与“极致优化”的思维：

| 特性 | 方法一：列表排序法 (Violent Sort) | 方法二：双指针迭代法 (Iterative Merge) |
|---|---|---|
| **核心逻辑** | 收集节点 -> 列表排序 -> 重新连接 | 谁小取谁 -> 移动指针 -> 挂载剩余 |
| **时间复杂度** | **$O(n \log n)$** (受排序函数限制) | **$O(n)$** (仅需遍历一次) |
| **空间复杂度** | **$O(n)$** (需要额外 List 存储引用) | **$O(1)$** (原地修改指针指向) |
| **适用场景** | 列表本身无序的情况 | **面试推荐**，利用了题目已排序的特性 |

---

### 💡 核心技术点解析

#### 1. 虚拟头节点 (Dummy Node) 🛡️
在方法二中，我使用了 `dummy = ListNode(0)`。这个小小的“假头”能帮我们避开“第一个节点该接谁”的繁琐判断，统一了合并逻辑，最后只需返回 `dummy.next`。

#### 2. 多条件排序 (Multi-condition Sort) ⚖️
在方法一的排序中，我使用了元组作为 `key`：
`key = lambda x: (x.val, id(x))`
*   **第一级**：按数值 `val` 升序排。
*   **第二级**：如果数值一样，按内存地址 `id` 排，确保排序的唯一性和稳定性。

#### 3. 极速封尾 (Tail Attachment) 🏁
`curr.next = list1 if list1 else list2`
这行代码展示了链表极其高效的一面：只要其中一个链表走完了，剩下的那一部分由于本身就有序，我们**不需要循环**，直接把指针连过去，整串车厢就瞬间合并完成了。

### - 递归篇 (Recursive Merge) 🌀

### 📝 递归思路：剥洋葱哲学
递归法的核心思想是：**“我只处理当前最简单的一步，剩下的交给函数自己去解决。”**

当我们合并两个有序链表时，逻辑可以简化为：
1.  比较两个链表的头节点。
2.  选出较小的那个作为“当前的头”。
3.  **递归**：剩下的车厢该怎么接？让 `mergeTwoLists` 函数再去处理剩下的部分，处理完后挂在当前头的 `next` 上。

---

### 🎨 递归三要素拆解

| 要素 | 逻辑说明 | 形象比喻 |
|---|---|---|
| **1. 递归出口 (Base Case)** | 如果其中一个链表为空，直接返回另一个链表。 | 洋葱剥到了心，或者已经没有套娃了。 |
| **2. 递归逻辑 (Recursive Step)** | `list1.next = self.mergeTwoLists(list1.next, list2)` | 选出本轮的优胜者，并让它去拉住后续的结果。 |
| **3. 返回值 (Return)** | 返回当前胜出的节点对象。 | 每一层都向上层汇报：“我已经接好我的部分了”。 |

