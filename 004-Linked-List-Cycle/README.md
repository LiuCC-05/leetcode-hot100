# 141. 环形链表 (Linked List Cycle) 🎡

### 📝 题目概述
给定一个链表，判断链表中是否有环。
*   **定义**：如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。
*   **核心挑战**：你能否在不使用额外空间（**$O(1)$ 空间复杂度**）的情况下完成判断？

---

### 🚀 核心策略：快慢指针 (弗洛伊德判圈法)
这是解决环形链表最经典、最优雅的算法，也被形象地称为“龟兔赛跑算法”。

| 角色 | 移动步长 | 形象类比 |
|---|---|---|
| **慢指针 (slow)** | 每次走 **1** 步 | 乌龟：稳扎稳打。 |
| **快指针 (fast)** | 每次走 **2** 步 | 兔子：速度翻倍。 |
*   **定义快慢** ：当fast,fast.next存在，然后此时写出slow = slow.next;fast步长为slow的两倍。两倍的步长可以实现fast一步步靠近slow，可以避免fast跳过slow导致错过的情况。

#### 💡 判别逻辑
1.  **如果没有环**：兔子（快指针）会率先到达终点（`None`），比赛结束。
2.  **如果有环**：兔子和乌龟都会进入环内。由于兔子比乌龟快，它们最终一定会在环内的某个位置**相遇**（兔子套了乌龟一圈）。

---

### 🎨 逻辑深度拆解：为什么比地址？

正如我们在讨论中领悟到的，判断“环”的本质是判断**“是否回到了同一个内存空间”**。

*   **错误做法**：比较 `slow.val == fast.val`。
    *   *风险*：链表中可能有多个节点的值都是 `1`，这会导致误判。
*   **正确做法**：比较 `slow == fast` (或 `slow is fast`)。
    *   *原理*：比较的是节点在内存中的**物理地址**。只有指向同一个对象，才证明“转回来了”。
